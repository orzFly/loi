import { expect } from 'chai';
import * as t from 'io-ts';
import { forEach } from 'lodash';
import { shouldNotValidate, shouldValidate } from '../test-helper.spec';
import { boolean } from './Boolean';

// tslint:disable:no-unused-expression // chai to be NaN

describe('types:Boolean', () => {
  describe('boolean', () => {
    it('should work', () => {
      const test = boolean()

      expect(test.name).to.be.eql("boolean")
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      shouldNotValidate(test.decode("on"))
      shouldNotValidate(test.decode("off"))
      shouldNotValidate(test.decode("1"))
      shouldNotValidate(test.decode("0"))
      shouldNotValidate(test.decode("yyyyes"))
      shouldNotValidate(test.decode("nnnnno"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('mimicked boolean should work', () => {
      const test = boolean

      expect(test.name).to.be.eql("boolean")
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      shouldNotValidate(test.decode("on"))
      shouldNotValidate(test.decode("off"))
      shouldNotValidate(test.decode("1"))
      shouldNotValidate(test.decode("0"))
      shouldNotValidate(test.decode("yyyyes"))
      shouldNotValidate(test.decode("nnnnno"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('trueOnly() should work', () => {
      const test = boolean().trueOnly()

      expect(test.name).to.be.eql("true")
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      shouldNotValidate(test.decode(false))
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('trueOnly(violet) should work', () => {
      const test = boolean().trueOnly(true)

      expect(test.name).to.be.eql("true(violet)")
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      expect(shouldValidate(test.decode(false))).to.be.eql(undefined)
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      expect(shouldValidate(test.decode(null))).to.be.eql(undefined)
      expect(shouldValidate(test.decode(undefined))).to.be.eql(undefined)
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('falseOnly() should work', () => {
      const test = boolean().falseOnly()

      expect(test.name).to.be.eql("false")
      shouldNotValidate(test.decode(true))
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('falseOnly(violet) should work', () => {
      const test = boolean().falseOnly(true)

      expect(test.name).to.be.eql("false(violet)")
      expect(shouldValidate(test.decode(true))).to.be.eql(undefined)
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      expect(shouldValidate(test.decode(null))).to.be.eql(undefined)
      expect(shouldValidate(test.decode(undefined))).to.be.eql(undefined)
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it(`[false/true]Only().[false/true]Only is not available`, () => {
      expect(boolean()).to.have.property('falseOnly');
      expect(boolean()).to.have.property('trueOnly');
      expect(boolean().falseOnly()).to.not.have.property('falseOnly');
      expect(boolean().falseOnly()).to.not.have.property('trueOnly');
      expect(boolean().trueOnly()).to.not.have.property('falseOnly');
      expect(boolean().trueOnly()).to.not.have.property('trueOnly');
    })

    it('parseString() should work', () => {
      const test = boolean().parseString()

      expect(test.name).to.be.eql("boolean(parseString)")
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      expect(shouldValidate(test.decode("true"))).to.be.eql(true)
      expect(shouldValidate(test.decode("false"))).to.be.eql(false)
      expect(shouldValidate(test.decode("yes"))).to.be.eql(true)
      expect(shouldValidate(test.decode("no"))).to.be.eql(false)
      expect(shouldValidate(test.decode("t"))).to.be.eql(true)
      expect(shouldValidate(test.decode("f"))).to.be.eql(false)
      expect(shouldValidate(test.decode("y"))).to.be.eql(true)
      expect(shouldValidate(test.decode("n"))).to.be.eql(false)
      expect(shouldValidate(test.decode("on"))).to.be.eql(true)
      expect(shouldValidate(test.decode("off"))).to.be.eql(false)
      expect(shouldValidate(test.decode("1"))).to.be.eql(true)
      expect(shouldValidate(test.decode("0"))).to.be.eql(false)
      shouldNotValidate(test.decode("yyyyes"))
      shouldNotValidate(test.decode("nnnnno"))
      shouldNotValidate(test.decode(0))
      shouldNotValidate(test.decode(1))
      shouldNotValidate(test.decode(-1))
      shouldNotValidate(test.decode(Infinity))
      shouldNotValidate(test.decode(NaN))
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('parseNumber() should work', () => {
      const test = boolean().parseNumber()

      expect(test.name).to.be.eql("boolean(parseNumber)")
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      shouldNotValidate(test.decode("true"))
      shouldNotValidate(test.decode("false"))
      shouldNotValidate(test.decode("yes"))
      shouldNotValidate(test.decode("no"))
      shouldNotValidate(test.decode("t"))
      shouldNotValidate(test.decode("f"))
      shouldNotValidate(test.decode("y"))
      shouldNotValidate(test.decode("n"))
      expect(shouldValidate(test.decode(0))).to.be.eql(false)
      expect(shouldValidate(test.decode(1))).to.be.eql(true)
      expect(shouldValidate(test.decode(-1))).to.be.eql(true)
      expect(shouldValidate(test.decode(Infinity))).to.be.eql(true)
      expect(shouldValidate(test.decode(NaN))).to.be.eql(false)
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    it('parse() should work', () => {
      const test = boolean().parse()

      expect(test.name).to.oneOf(["boolean(parseString, parseNumber)", "boolean(parseNumber, parseString)"])
      expect(shouldValidate(test.decode(true))).to.be.eql(true)
      expect(shouldValidate(test.decode(false))).to.be.eql(false)
      expect(shouldValidate(test.decode("true"))).to.be.eql(true)
      expect(shouldValidate(test.decode("false"))).to.be.eql(false)
      expect(shouldValidate(test.decode("yes"))).to.be.eql(true)
      expect(shouldValidate(test.decode("no"))).to.be.eql(false)
      expect(shouldValidate(test.decode("t"))).to.be.eql(true)
      expect(shouldValidate(test.decode("f"))).to.be.eql(false)
      expect(shouldValidate(test.decode("y"))).to.be.eql(true)
      expect(shouldValidate(test.decode("n"))).to.be.eql(false)
      expect(shouldValidate(test.decode(0))).to.be.eql(false)
      expect(shouldValidate(test.decode(1))).to.be.eql(true)
      expect(shouldValidate(test.decode(-1))).to.be.eql(true)
      expect(shouldValidate(test.decode(Infinity))).to.be.eql(true)
      expect(shouldValidate(test.decode(NaN))).to.be.eql(false)
      shouldNotValidate(test.decode(null))
      shouldNotValidate(test.decode(undefined))
      shouldNotValidate(test.decode([]))
      shouldNotValidate(test.decode({}))
      shouldNotValidate(test.decode(new RegExp(/./)))
      shouldNotValidate(test.decode(() => { }))
    })

    forEach({
      "trueOnly().parseString().parseNumber()": [boolean().trueOnly().parseString().parseNumber(), "true(parseString, parseNumber)"],
      "trueOnly().parseNumber().parseString()": [boolean().trueOnly().parseNumber().parseString(), "true(parseNumber, parseString)"],
    } as { [key: string]: [t.Any, string] }, ([type, name], key) => {
      it(`${key} should work`, () => {
        const test = type

        expect(test.name).to.be.eql(name)
        expect(shouldValidate(test.decode(true))).to.be.eql(true)
        shouldNotValidate(test.decode(false))
        expect(shouldValidate(test.decode("true"))).to.be.eql(true)
        shouldNotValidate(test.decode("false"))
        expect(shouldValidate(test.decode("yes"))).to.be.eql(true)
        shouldNotValidate(test.decode("no"))
        expect(shouldValidate(test.decode("t"))).to.be.eql(true)
        shouldNotValidate(test.decode("f"))
        expect(shouldValidate(test.decode("y"))).to.be.eql(true)
        shouldNotValidate(test.decode("n"))
        shouldNotValidate(test.decode(0))
        expect(shouldValidate(test.decode(1))).to.be.eql(true)
        expect(shouldValidate(test.decode(-1))).to.be.eql(true)
        expect(shouldValidate(test.decode(Infinity))).to.be.eql(true)
        shouldNotValidate(test.decode(NaN))
        shouldNotValidate(test.decode(null))
        shouldNotValidate(test.decode(undefined))
        shouldNotValidate(test.decode([]))
        shouldNotValidate(test.decode({}))
        shouldNotValidate(test.decode(new RegExp(/./)))
        shouldNotValidate(test.decode(() => { }))
      })
    })

    forEach({
      "trueOnly(violet).parseString().parseNumber()": [boolean().trueOnly(true).parseString().parseNumber(), "true(violet, parseString, parseNumber)"],
      "trueOnly(violet).parseNumber().parseString()": [boolean().trueOnly(true).parseNumber().parseString(), "true(violet, parseNumber, parseString)"],
    } as { [key: string]: [t.Any, string] }, ([type, name], key) => {
      it(`${key} should work`, () => {
        const test = type

        expect(test.name).to.be.eql(name)
        expect(shouldValidate(test.decode(true))).to.be.eql(true)
        expect(shouldValidate(test.decode(false))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("true"))).to.be.eql(true)
        expect(shouldValidate(test.decode("false"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("yes"))).to.be.eql(true)
        expect(shouldValidate(test.decode("no"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("t"))).to.be.eql(true)
        expect(shouldValidate(test.decode("f"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("y"))).to.be.eql(true)
        expect(shouldValidate(test.decode("n"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(0))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(1))).to.be.eql(true)
        expect(shouldValidate(test.decode(-1))).to.be.eql(true)
        expect(shouldValidate(test.decode(Infinity))).to.be.eql(true)
        expect(shouldValidate(test.decode(NaN))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(null))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(undefined))).to.be.eql(undefined)
        shouldNotValidate(test.decode([]))
        shouldNotValidate(test.decode({}))
        shouldNotValidate(test.decode(new RegExp(/./)))
        shouldNotValidate(test.decode(() => { }))
      })
    })

    forEach({
      "falseOnly().parseString().parseNumber()": [boolean().falseOnly().parseString().parseNumber(), "false(parseString, parseNumber)"],
      "falseOnly().parseNumber().parseString()": [boolean().falseOnly().parseNumber().parseString(), "false(parseNumber, parseString)"],
    } as { [key: string]: [t.Any, string] }, ([type, name], key) => {
      it(`${key} should work`, () => {
        const test = type

        expect(test.name).to.be.eql(name)
        shouldNotValidate(test.decode(true))
        expect(shouldValidate(test.decode(false))).to.be.eql(false)
        shouldNotValidate(test.decode("true"))
        expect(shouldValidate(test.decode("false"))).to.be.eql(false)
        shouldNotValidate(test.decode("yes"))
        expect(shouldValidate(test.decode("no"))).to.be.eql(false)
        shouldNotValidate(test.decode("t"))
        expect(shouldValidate(test.decode("f"))).to.be.eql(false)
        shouldNotValidate(test.decode("y"))
        expect(shouldValidate(test.decode("n"))).to.be.eql(false)
        expect(shouldValidate(test.decode(0))).to.be.eql(false)
        shouldNotValidate(test.decode(1))
        shouldNotValidate(test.decode(-1))
        shouldNotValidate(test.decode(Infinity))
        expect(shouldValidate(test.decode(NaN))).to.be.eql(false)
        shouldNotValidate(test.decode(null))
        shouldNotValidate(test.decode(undefined))
        shouldNotValidate(test.decode([]))
        shouldNotValidate(test.decode({}))
        shouldNotValidate(test.decode(new RegExp(/./)))
        shouldNotValidate(test.decode(() => { }))
      })
    })

    forEach({
      "falseOnly(violet).parseString().parseNumber()": [boolean().falseOnly(true).parseString().parseNumber(), "false(violet, parseString, parseNumber)"],
      "falseOnly(violet).parseNumber().parseString()": [boolean().falseOnly(true).parseNumber().parseString(), "false(violet, parseNumber, parseString)"],
    } as { [key: string]: [t.Any, string] }, ([type, name], key) => {
      it(`${key} should work`, () => {
        const test = type

        expect(test.name).to.be.eql(name)
        expect(shouldValidate(test.decode(true))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(false))).to.be.eql(false)
        expect(shouldValidate(test.decode("true"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("false"))).to.be.eql(false)
        expect(shouldValidate(test.decode("yes"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("no"))).to.be.eql(false)
        expect(shouldValidate(test.decode("t"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("f"))).to.be.eql(false)
        expect(shouldValidate(test.decode("y"))).to.be.eql(undefined)
        expect(shouldValidate(test.decode("n"))).to.be.eql(false)
        expect(shouldValidate(test.decode(0))).to.be.eql(false)
        expect(shouldValidate(test.decode(1))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(-1))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(Infinity))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(NaN))).to.be.eql(false)
        expect(shouldValidate(test.decode(null))).to.be.eql(undefined)
        expect(shouldValidate(test.decode(undefined))).to.be.eql(undefined)
        shouldNotValidate(test.decode([]))
        shouldNotValidate(test.decode({}))
        shouldNotValidate(test.decode(new RegExp(/./)))
        shouldNotValidate(test.decode(() => { }))
      })
    })
  })
})